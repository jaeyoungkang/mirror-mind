# AI Engineering Methodology

AI와 인간이 함께 코드베이스를 일관성 있게 유지하기 위한 방법론입니다.

---

## 1. 핵심 원칙

### 문서-코드 동기화 (Doc-Code Sync)

> **모든 비즈니스 로직은 문서와 코드 양쪽에 존재하며, 항상 동기화되어야 한다.**

| 대상 | 문서 (인간용) | 코드 (AI 주입용) |
|------|--------------|-----------------|
| 의미 모델 | `contexts/semantic-principles.md` | `lib/semantic-principles.ts` |
| 글쓰기 원칙 | `contexts/writing-principles.md` | `lib/writing-principles.ts` |
| 클러스터링 원칙 | `contexts/clustering-principles.md` | `lib/clustering-principles.ts` |
| 클러스터링 전략 | `contexts/clustering-strategy.md` | `lib/clustering-strategies.ts` |

### 삼분법 (Tripartite Pattern)

도메인 로직을 세 가지 관점으로 분리합니다:

```
┌─────────────────────────────────────────────────────────────┐
│                     도메인 로직                              │
├───────────────┬───────────────────┬─────────────────────────┤
│   원칙        │      전략         │        출력              │
│  (Principles) │    (Strategy)     │      (Output)           │
├───────────────┼───────────────────┼─────────────────────────┤
│ AI가 알아야   │ 코드가 수행하는   │ 결과물의 구조           │
│ 하는 것       │ 방법              │                         │
├───────────────┼───────────────────┼─────────────────────────┤
│ 프롬프트 주입 │ 구현 로직         │ 타입/인터페이스         │
├───────────────┼───────────────────┼─────────────────────────┤
│ *-principles  │ *-strategies      │ *-format / types        │
│ .ts / .md     │ .ts / .md         │ .md / .ts               │
└───────────────┴───────────────────┴─────────────────────────┘
```

**예시: 클러스터링**

| 관점 | 파일 | 내용 |
|------|------|------|
| 원칙 | `clustering-principles.*` | 시간적 우선순위, Thesis-First, thesisConnection 가이드 |
| 전략 | `clustering-strategy.*` | Direct/Distributed 모드, 처리 흐름, 비용 분석 |
| 출력 | `cluster-result-format.md` | ClusterResult, Cluster, Gap 타입 정의 |

---

## 2. 문서 계층 구조

```
┌─────────────────────────────────────────────────────────────┐
│                       CLAUDE.md                             │
│              AI 작업 지침 및 동기화 규칙                      │
│         "어떤 파일을 수정할 때 어떤 파일도 확인하라"           │
└─────────────────────────────────────────────────────────────┘
                              │
          ┌───────────────────┼───────────────────┐
          ▼                   ▼                   ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│    SPEC.md      │  │   README.md     │  │    TECH.md      │
│  프로젝트 설계   │  │   사용자 가이드  │  │   기술 스펙     │
│  "무엇을, 왜"    │  │   "어떻게 쓰나"  │  │  "어떻게 구현"   │
└─────────────────┘  └─────────────────┘  └─────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      contexts/                              │
│                  도메인별 상세 문서                           │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ semantic-    │  │ writing-     │  │ clustering-  │       │
│  │ model.md     │  │ principles.md│  │ *.md         │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                         lib/                                │
│                    코드 구현체                               │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ semantic-    │  │ writing-     │  │ clustering-  │       │
│  │ principles.ts│  │ principles.ts│  │ *.ts         │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 각 문서의 역할

| 문서 | 독자 | 목적 | 수정 시점 |
|------|------|------|----------|
| `CLAUDE.md` | AI | 작업 지침, 동기화 규칙 | 새 도메인 추가 시 |
| `SPEC.md` | 인간+AI | 프로젝트 설계, 핵심 개념 | 기능 변경 시 |
| `README.md` | 사용자 | 서비스 사용법 | UI 변경 시 |
| `TECH.md` | 개발자 | 기술 스택, 구조 | 인프라 변경 시 |
| `contexts/*.md` | 인간+AI | 도메인 상세 로직 | 비즈니스 로직 변경 시 |
| `lib/*-principles.ts` | AI | 프롬프트 주입 원칙 | 원칙 변경 시 |
| `lib/*-strategies.ts` | 코드 | 구현 로직 | 전략 변경 시 |

---

## 3. 동기화 워크플로우

### 변경 시 체크리스트

**원칙 변경 시:**
```
contexts/*-principles.md 수정
        ↓
lib/*-principles.ts 동기화
        ↓
관련 프롬프트 사용처 확인
        ↓
CLAUDE.md 규칙 확인
```

**전략 변경 시:**
```
contexts/*-strategy.md 수정
        ↓
lib/*-strategies.ts 동기화
        ↓
API 라우트 확인
        ↓
TECH.md 업데이트 (필요시)
```

**새 도메인 추가 시:**
```
1. contexts/new-domain.md 작성
        ↓
2. lib/new-domain-principles.ts 작성 (필요시)
        ↓
3. lib/new-domain-strategies.ts 작성 (필요시)
        ↓
4. CLAUDE.md에 동기화 규칙 추가
        ↓
5. SPEC.md 문서 참조 테이블 업데이트
        ↓
6. TECH.md 디렉토리 구조 업데이트
```

### CLAUDE.md 동기화 규칙 템플릿

```markdown
## [Domain Name] 일관성 유지

다음 파일들은 [도메인 설명]을 정의하며 반드시 일관성을 유지해야 한다:

| 파일 | 용도 |
|------|------|
| `lib/domain-principles.ts` | 코드용 (프롬프트에 주입) |
| `contexts/domain-principles.md` | 문서용 (사람이 읽는 설명) |

**교차 검증 규칙:**
1. `lib/domain-principles.ts` 수정 시 → `contexts/domain-principles.md` 확인 및 동기화
2. `contexts/domain-principles.md` 수정 시 → `lib/domain-principles.ts` 확인 및 동기화

**동기화 대상:**
- [동기화 항목 1]
- [동기화 항목 2]
```

---

## 4. 삼분법 적용 가이드

### 언제 원칙(Principles)을 만드는가?

- AI가 판단해야 하는 기준이 있을 때
- 프롬프트에 주입할 도메인 지식이 있을 때
- "무엇이 좋은/올바른 것인가"를 정의할 때

**예시:**
- 시간적 우선순위: "최신 유닛이 더 신뢰할 만하다"
- Thesis-First: "핵심 주장을 먼저 추출하라"
- 연결 강도: "strong/moderate/weak 기준"

### 언제 전략(Strategy)을 만드는가?

- 처리 방식에 여러 옵션이 있을 때
- 조건에 따라 다른 로직을 실행할 때
- "어떻게 처리하는가"를 정의할 때

**예시:**
- 클러스터링 모드: auto/direct/distributed
- 처리 흐름: 1단계 → 2단계 → 3단계
- 임계값: 500개 이상이면 distributed

### 언제 출력(Output)을 만드는가?

- 결과물의 구조가 명확히 정의되어야 할 때
- 타입/인터페이스가 필요할 때
- "무엇이 나오는가"를 정의할 때

**예시:**
- ClusterResult 구조
- Gap 타입
- FlowAnalysis 인터페이스

---

## 5. 의존성 관리

### 원칙 → 전략 의존성

전략은 원칙을 참조하여 프롬프트를 구성합니다:

```typescript
// lib/clustering-strategies.ts
import {
  getDirectStrategyPrinciples,
  getDistributedStep1Principles,
} from "@/lib/clustering-principles";

// Direct 전략에서 원칙 주입
const prompt = `
${getDirectStrategyPrinciples()}

다음 의미 단위를 분석하세요...
`;
```

### 전략별 원칙 매핑

```
┌─────────────────────────────────────────────────────────────┐
│                        전략                                 │
├─────────────────────┬───────────────────────────────────────┤
│       Direct        │           Distributed                 │
├─────────────────────┼───────────────────────────────────────┤
│ 시간적 우선순위     │ 1단계: 시간적 우선순위 + Thesis-First │
│                     │ 2단계: thesisConnection 가이드        │
│                     │ 3단계: 일관성 검증 기준               │
└─────────────────────┴───────────────────────────────────────┘
```

---

## 6. 핵심 요약

> **AI Engineering Methodology**는 다음 세 가지를 보장합니다:
>
> 1. **문서-코드 동기화**: 인간이 읽는 문서와 AI가 사용하는 코드가 항상 일치
> 2. **삼분법 분리**: 원칙/전략/출력을 명확히 분리하여 유지보수성 향상
> 3. **계층적 문서 구조**: CLAUDE.md → SPEC.md/README.md/TECH.md → contexts/ → lib/
>
> 이 방법론을 따르면:
> - AI는 일관된 판단 기준을 갖게 됩니다
> - 인간은 변경 사항을 쉽게 추적할 수 있습니다
> - 코드베이스는 자기 문서화(self-documenting) 상태를 유지합니다
