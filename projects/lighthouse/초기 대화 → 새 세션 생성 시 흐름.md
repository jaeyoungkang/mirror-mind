초기 대화 → 새 세션 생성 시 흐름

  전제: 사용자가 첫 대화(대화 A)를 진행한 뒤, 새 대화 세션(대화 B)을 열고 첫 메시지를 보낸다.

  handleChatTurn(conversationId=B, messages=[userMsg]) 진입

  Phase 1: parseAndPersistInput

  - messages.length === 1 → 제목 설정 + 메시지 저장. 문제 없음.

  Phase 2: loadActivatedMemory(B, messages) — 4개 병렬 쿼리

  ┌───────────────────────────────┬──────────────────────────────┬──────────────────────────────────────────────────────────────────────┐
  │             쿼리              │             결과             │                                 설명                                 │
  ├───────────────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
  │ activateMemory(queryText)     │ 대화 A에서 추출된 노드가     │ 대화 A가 끝난 후 노드 추출이 완료되었으면 노드가 있고, 활성화 가능.  │
  │                               │ 있는지에 달림                │ 추출 전이면 countNodes=0 → 빈 배열                                   │
  ├───────────────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
  │ listRecentResearchDocuments() │ 대화 A에서 생성된 연구 문서  │ 있으면 반환                                                          │
  ├───────────────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
  │ countExperienceNodes()        │ 대화 A에서 노드가            │ isFirstVisit = false                                                 │
  │                               │ 추출되었으면 > 0             │                                                                      │
  ├───────────────────────────────┼──────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
  │ getLastConversationAt(B)      │ 대화 A의 updated_at          │ 대화 A가 존재하므로 반환됨                                           │
  └───────────────────────────────┴──────────────────────────────┴──────────────────────────────────────────────────────────────────────┘

  핵심 문제: isFirstVisit과 hasMemory의 판단 시점이 다르다.

  - isFirstVisit: countExperienceNodes() === 0으로 판단. 대화 A에서 노드 추출이 아직 안 됐으면 true, 됐으면 false.
  - hasMemory: activatedNodes.length > 0 || recentDocuments.length > 0으로 판단. 노드가 추출되었더라도 사용자 메시지("안녕")와 유사도가
  낮으면 활성화 0개 → false.

  Phase 3: buildPrompt — 분기별 결과

  케이스 1: 대화 A의 노드 추출 완료 + 활성화 성공
  - isFirstVisit=false, hasMemory=true
  - → REVISIT_SECTION + 메모리 섹션(시간 맥락 포함) 주입. 정상 동작.

  케이스 2: 대화 A의 노드 추출 완료 + 활성화 실패 (예: "안녕"으로 유사도 낮음)
  - isFirstVisit=false, hasMemory=false
  - → REVISIT_SECTION 미주입. memorySection 없음. BASE_SYSTEM_PROMPT만 나감.
  - 코르카는 첫 방문도 재방문도 아닌 무지시 상태로 응답.

  케이스 3: 대화 A의 노드 추출 미완료
  - countExperienceNodes()=0 → isFirstVisit=true
  - → FIRST_VISIT_SECTION 주입. 사실은 재방문인데 첫 방문으로 처리됨.

  ---
  케이스 2가 현재 구조의 빈 구멍입니다. 재방문인데 기억이 활성화되지 않으면 어떤 행동 지시도 없이 BASE_SYSTEM_PROMPT만 적용됩니다.

❯ 아니야 근본적인 재설계가 필요해보인다. 이거는 상위 에이전트와 논의할테니 맥락정보 상세히 알려줘 직접 전달하겠다.  

⏺ 재방문 흐름 — 상위 에이전트 논의용 맥락 정리

  현재 구조

  handleChatTurn(conversationId, messages)
    ├─ parseAndPersistInput()        # 메시지 저장
    ├─ loadActivatedMemory()         # 4개 병렬 쿼리
    │    ├─ activateMemory(queryText)       → ActivatedNode[]
    │    ├─ listRecentResearchDocuments()   → Artifact[]
    │    ├─ countExperienceNodes()          → number (isFirstVisit 판단)
    │    └─ getLastConversationAt(id)       → string | null  ← 신규 추가
    ├─ buildPrompt()                 # 분기 판단 + 프롬프트 조립
    │    ├─ hasMemory = activatedNodes > 0 || recentDocuments > 0
    │    ├─ isFirstVisit = experienceCount === 0
    │    ├─ buildMemoryPrompt()      → 시간 맥락 + 노드 + 문서 + 규칙
    │    └─ buildSystemPrompt(memorySection, isFirstVisit, hasMemory)
    │         ├─ isFirstVisit         → FIRST_VISIT_SECTION
    │         ├─ !isFirstVisit && hasMemory → REVISIT_SECTION
    │         └─ !isFirstVisit && !hasMemory → 아무것도 없음 ← 구멍
    └─ streamLLM()

  분기 매트릭스 — 5가지 케이스

  ┌─────┬─────────────────┬────────────────┬────────────┬──────────────┬───────────┬──────────────────────────┬──────┐
  │  #  │ experienceNodes │ activatedNodes │ recentDocs │ isFirstVisit │ hasMemory │           결과           │ 판정 │
  ├─────┼─────────────────┼────────────────┼────────────┼──────────────┼───────────┼──────────────────────────┼──────┤
  │ 1   │ 0               │ 0              │ 0          │ true         │ false     │ FIRST_VISIT_SECTION      │ 정상 │
  ├─────┼─────────────────┼────────────────┼────────────┼──────────────┼───────────┼──────────────────────────┼──────┤
  │ 2   │ >0              │ >0             │ any        │ false        │ true      │ REVISIT_SECTION + 메모리 │ 정상 │
  ├─────┼─────────────────┼────────────────┼────────────┼──────────────┼───────────┼──────────────────────────┼──────┤
  │ 3   │ >0              │ 0              │ >0         │ false        │ true      │ REVISIT_SECTION + 문서만 │ 정상 │
  ├─────┼─────────────────┼────────────────┼────────────┼──────────────┼───────────┼──────────────────────────┼──────┤
  │ 4   │ >0              │ 0              │ 0          │ false        │ false     │ BASE만                   │ 구멍 │
  ├─────┼─────────────────┼────────────────┼────────────┼──────────────┼───────────┼──────────────────────────┼──────┤
  │ 5   │ 0 (추출 지연)   │ 0              │ 0          │ true         │ false     │ FIRST_VISIT_SECTION      │ 오판 │
  └─────┴─────────────────┴────────────────┴────────────┴──────────────┴───────────┴──────────────────────────┴──────┘

  케이스 4: 재방문인데 "안녕" 같은 짧은 인사로 유사도 매칭 실패 → 기억 활성화 0개, 문서도 없음. REVISIT_SECTION도 시간 맥락도 주입 안 됨.
  코르카는 행동 지시 없는 상태.

  케이스 5: 대화 A 직후 노드 추출이 아직 완료되지 않은 타이밍에 새 세션을 열면 experienceCount=0 → 첫 방문으로 오판. 다시 자기소개부터
  시작할 수 있음.

  근본 원인

  isFirstVisit과 hasMemory가 서로 다른 기준으로 판단된다.

  - isFirstVisit: 존재 기준 — experience 노드가 DB에 있는가 (countExperienceNodes)
  - hasMemory: 활성화 기준 — 이번 쿼리에서 노드가 매칭되었는가 (activateMemory 결과)

  이 두 기준 사이에 갭이 있다. 노드는 존재하지만 활성화되지 않는 상태(케이스 4)가 가능하고, 존재해야 하지만 아직 없는 상태(케이스 5)도
  가능하다.

  활성화 시스템 상세 (activate.ts)

  activateMemory(userMessage)
    1. countNodes(uid) → 0이면 빈 배열 반환
    2. computeEmbedding(userMessage) → 벡터 계산
    3. nodeCount < 13이면 → 임베딩 유사도 top-N만 (네트워크 스킵)
       nodeCount >= 13이면 → seed 3개 + spreading activation 2-hop
    4. 상위 15개 반환

  "안녕"의 임베딩과 연구 관련 노드들의 유사도가 낮으면, seed 매칭 자체가 약해서 활성화 결과가 비거나 무관한 노드만 나올 수 있다. 임베딩
  유사도 기반이라 일상 인사에는 구조적으로 취약하다.

  lastConversationAt — 이번에 추가된 부분

  conversations 테이블에서 현재 대화를 제외한 가장 최근 대화의 updated_at을 조회한다. 이 값 자체는 정상 작동하지만, 케이스 4에서
  hasMemory=false이면 buildMemoryPrompt가 호출되지 않아 시간 맥락이 프롬프트에 도달하지 못한다.

  현재 코드에서 변경된 파일들

  ┌─────────────────────────────┬────────────────────────────────────────────────────────┬──────────────────────────────────┐
  │            파일             │                       변경 내용                        │               상태               │
  ├─────────────────────────────┼────────────────────────────────────────────────────────┼──────────────────────────────────┤
  │ repository/conversations.ts │ getLastConversationAt() 추가                           │ 완료, 단독으로 유효              │
  ├─────────────────────────────┼────────────────────────────────────────────────────────┼──────────────────────────────────┤
  │ agent/orchestrator.ts       │ loadActivatedMemory에서 lastConversationAt 병렬 조회   │ 완료, 단독으로 유효              │
  ├─────────────────────────────┼────────────────────────────────────────────────────────┼──────────────────────────────────┤
  │ memory/prompt.ts            │ formatTimeSince() + buildMemoryPrompt에 시간 맥락 주입 │ 완료, hasMemory=true일 때만 동작 │
  ├─────────────────────────────┼────────────────────────────────────────────────────────┼──────────────────────────────────┤
  │ agent/system-prompt.ts      │ REVISIT_SECTION + buildSystemPrompt(_, _, hasMemory)   │ 완료, hasMemory=true일 때만 동작 │
  └─────────────────────────────┴────────────────────────────────────────────────────────┴──────────────────────────────────┘

  논의 포인트

  1. 방문 상태 판단 기준을 어디에 둘 것인가 — 활성화(매칭) vs 존재(DB) vs 세션(conversations)
  2. 활성화 실패 시 fallback — 허브 노드 상시 활성화, is_hub 플래그 활용, 또는 별도 판단 경로
  3. 노드 추출 타이밍 — 동기 vs 비동기, 새 세션 진입 전 보장 가능한 구조
  4. 시간 맥락의 소속 — 기억 시스템의 일부인가, 독립적인 세션 정보인가