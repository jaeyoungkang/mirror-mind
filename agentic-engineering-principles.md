# 에이전틱 엔지니어링 원칙

AI 에이전트 서비스의 설계와 개발을 관통하는 원칙. 철학은 `mirror-mind-principle.md`를 따른다.

---

## 핵심 전제

### 1. 자율성은 디자인 선택이다
"AI가 할 수 있는가"가 아니라 "누가 주도해야 더 나은 경험인가"가 기준이다.

### 2. 리트머스 테스트: 도구인가 동료인가
새 기능/설계 결정 시 "이것은 도구의 행동인가, 동료의 행동인가"를 묻는다. 도구의 행동이라면 동료의 행동으로 재설계한다.

### 3. 정확함보다 자연스러움을 우선한다
검색 정확도나 기술적 최적화보다 사용자 경험의 자연스러움이 설계 판단의 우선 기준이다. 기억 시스템에서 "정확한 검색"이 아니라 "자연스러운 대화"를 평가 기준으로 삼았을 때 설계가 단순해지고 결과가 좋아졌다.

---

## 서비스 설계

### 자율성 프레임워크

**판단 기준:**
- 되돌림 비용: 잘못됐을 때 고치기 쉬운가?
- 판단의 개인성: 정답이 사용자 취향/목적에 달렸나?
- 맥락 전환 비용: 사용자가 직접 하면 흐름이 끊기나?

**5단계:**
- **L1** 사용자 주도, AI 보조
- **L2** AI 제안, 사용자 즉시 수정
- **L3** AI 계획, 중요 판단은 사용자 자문
- **L4** AI 실행 준비, 최종 승인 대기
- **L5** AI 자율 실행, 사용자 모니터링

**설계 규칙:**
1. 자율성 수준은 설계 시점에 고정한다
2. 자율성이 높을수록 검증은 강해야 한다 (정비례)
3. 고위험 판단에는 계획 후 실행(Plan-Then-Execute)을 적용한다
4. 맥락은 분리하지 않고 쌓는다

**코드로 강제하기 — FSM 패턴:**

자율성 레벨을 코드로 강제하는 가장 효과적인 패턴은 명시적 FSM이다.
- **상태(Stage)**: `IDLE → EXECUTING → AWAITING_APPROVAL → SUCCEEDED`
- **전이 함수**: `canTransition(currentStage, event) → boolean`
- **게이트**: 특정 전이에서 사용자 승인 이벤트가 필수

핵심: **버튼 비활성화(UI)가 아니라 전이 함수(정책)가 접근을 통제한다.**

### 안전

**UX 안전망:**
- 진행 상황 가시화 (Thinking HUD)
- 능동적 개입 (Emergency Stop)
- 가역성 보장 (Undo)
- 부분 재생성

**코드 레벨:**
- 샌드박싱 — 에이전트 실행은 격리 환경. 최소 권한 원칙
- 권한 분류 — 읽기=자동, 쓰기=검토, 삭제·배포=명시적 승인
- 린트·정적 분석 필수 — 에이전트 코드도 동일한 린트 규칙 통과
- 다중 검증 — 작성 에이전트와 검토 에이전트 분리

**비즈니스 레벨:**
- 승인 워크플로 — 프로덕션 변경은 사람 승인
- 롤백 보장 — 60초 내 되돌릴 수 없으면 안전장치 부족
- 비용 상한 — 세션/태스크/일 단위 한도 (Denial of Wallet 방지)
- 감사 추적 — 모든 도구 호출, LLM 상호작용, 의사결정 지점 기록

### 제어감 (Sense of Agency)
- 인과관계 명시: 사용자 의도 → AI 결과의 연결고리 시각화
- 공동 주체성: AI 작업 과정을 실시간 노출
- 신뢰도 시각화: High/Medium/Low로 검토 노력 최적화

### 관계 형성

별도 온보딩 화면이나 설문을 두지 않는다. **관계 형성도 동료가 대화를 통해 직접 수행한다.** 첫 대화에서 끝나는 단계가 아니라 모든 상호작용에서 깊어지는 연속적 과정이다.

**핵심 명제:** 두 동료의 관계는 지식과 정보의 교환만으로 만들어지지 않는다. **함께 헤매고, 실패하고, 돌파하는 경험이 동료 관계를 만든다.**

**기본 원칙:**
1. **따뜻함이 역량보다 먼저** — 의도(선의)를 능력보다 먼저 보여야 한다
2. **AI가 먼저 자기를 연다** — 호혜적 자기 노출이 관계 심화의 메커니즘
3. **첫 경험이 관계를 결정한다** — 첫 상호작용에 가장 많은 설계 자원을 투자
4. **함께 해본 경험이 전환점** — 도구→동료 전환은 설명이 아니라 공유 경험에서 온다
5. **한계 인정이 신뢰를 만든다** — 불확실할 때 솔직히 인정
6. **호혜성의 재설계** — "사용자가 투자한 만큼 AI가 더 유용해지는 것"으로 구현

**상호 맥락 파악:**
- AI가 파악할 것: 사용자의 분야, 현재 단계, 상황 — 자연스러운 대화로
- 사용자가 알게 될 것: AI의 능력, 협업 방식, 한계 — 함께 경험하면서
- 각 기능의 첫 수행 시 간단한 설명, 두 번째부터는 설명 없이 수행

**경험 추적 — 관계의 기억:**

| 차원 | 설명 | 예시 |
|------|------|------|
| 활동 | 무엇을 함께 했는가 | 첫 검색, 첫 분석 |
| 결과 | 성공/실패/예상 밖 | 갭 발견이 방향을 바꿈 |
| 관계 | 둘 사이에 어떤 일이 | 의견 충돌 후 조율, 함께 돌파 |

**관계 깊이에 따른 행동 변화:**

| 단계 | 기준 | AI의 변화 |
|------|------|----------|
| 초기 | 경험 소수 | 설명 곁들임, 낮은 자율성, 자주 확인 |
| 형성 | 활동 경험 축적 | 설명 줄임, 자율성 점진적 상승 |
| 신뢰 | 실패 후 회복 경험 | 높은 자율성, 능동적 제안, 간결한 소통 |
| 깊은 협력 | 돌파 경험 공유 | 연구 파트너 수준, 맥락 깊이 최대 활용 |

핵심: **신뢰 단계로의 전환에는 "어려운 경험"(실패 후 회복, 의견 충돌 후 조율)이 필수다.**

**근거:** Fiske 따뜻함/역량 모델, Aron 36 Questions, Mayer 신뢰 모델, 신속 신뢰 이론

### 사용자 행동의 깊은 이해

AI 동료 서비스에서 진짜 UI/UX는 시각적 컴포넌트가 아니라 대화의 품질이다.

1. **사용자 행동 시나리오를 수집한다** — 학술 연구·UX 리서치·인터뷰에서. 행동 패턴이 설계의 출발점
2. **시나리오가 자율성 설계를 결정한다** — 같은 기능이라도 시나리오에 따라 적절한 자율성이 다르다
3. **동료는 시나리오의 전체 흐름을 안다** — 개별 요청 반응은 도구. 다음 단계를 선제적으로 제안하는 것이 동료
4. **시나리오는 점진적으로 커버한다** — 핵심부터 작게, 실전 피드백으로 확장

### 기억 시스템 설계

동료는 상대를 기억한다. 기억 시스템은 검색 엔진이 아니라 자연스러운 대화를 위한 인프라다.

**핵심 설계:**
- 노드 타입은 **fact + intention** 두 가지뿐. 감정·해석·연상은 노드가 아니라 사실+의도가 함께 활성화되면 **발현**되는 것
- 발현된 것 중 의미 있는 것은 새로운 fact 노드로 저장 (기억의 축적)
- 네트워크: knn_k12 단일 구조, spreading activation으로 맥락 기반 활성화
- 정체성 허브 노드: `is_hub` 지정, 새 노드 추가 시 허브와 추가 연결 → 정체성이 묻히지 않음
- 평가 기준은 검색 정확도가 아니라 **대화 자연스러움** (v3 실험에서 확정)

**설계 근거:** `memory/simulation/v3/experiment-report.md`

### 동료의 산출물: 데이터가 아니라 문서

**고정된 UI 컴포넌트에 데이터를 채우는 것은 도구 패러다임이다. LLM이 맥락에 맞는 문서를 동적으로 작성하는 것이 동료 패러다임이다.**

1. **AI가 구조를 결정한다** — 레이아웃과 서사 구조를 개발자가 미리 정의하지 않는다
2. **마크다운이 범용 포맷이다** — 인터랙티브 슬롯은 최소한으로
3. **문서는 점진적으로 풍부해진다** — 작업 진행에 따라 갱신

---

## 개발 방법론

### 모든 것은 파일이다 (Everything is a File)

Unix가 디바이스·프로세스·소켓을 모두 파일이라는 단일 추상화로 다뤘듯, **다양한 대상을 가능하면 동일한 추상화로 묶어 단순하게 만든다.** 이 철학은 개발과 에이전트 설계 양쪽에 적용된다.

핵심: 파일 자체가 목적이 아니라, **추상화를 하나로 수렴시키는 설계 판단**이 목적이다.

#### 시스템 인터페이스 — 파일로 노출하라

에이전트는 파일을 통해 시스템과 상호작용한다. 파일로 접근할 수 없는 것은 에이전트에게 존재하지 않는다.

- 설정 → 파일 (.env.example, .yaml, .json). 하드코딩 금지
- 스키마 → 파일에 선언 (타입 정의, 마이그레이션). 런타임 생성 회피
- 인프라 → 선언적 파일 (Dockerfile, CI yaml). GUI 설정 의존 금지
- 의존성 → 매니페스트 파일이 진실의 원본
- 상태 전이 → 선언적으로 읽을 수 있는 구조
- 규칙 → 설정 파일로 강제 (린트, 포맷터). 구두 합의 금지

위반 예시:
- 환경변수를 추가하면서 .env.example에 안 넣음
- API 스키마가 코드 실행해야만 알 수 있음
- 배포가 웹 콘솔 클릭으로만 가능

#### 코드 인터페이스 — 균일하게 구현하라

Unix에서 모든 디바이스가 read/write로 통일되듯, 코드에서 같은 종류의 것은 같은 인터페이스로 통일한다. 에이전트가 코드를 읽을 때도, 생성할 때도 이 규칙을 따른다.

- 기존 패턴을 먼저 파악하고, 그 패턴을 따른다
- 새로운 인터페이스를 발명하지 않는다
- 특수 경로를 만들지 않는다 — 공통 경로를 통과시킨다
- 예외를 만들 때는 기존 예외 처리 방식을 따른다

위반 예시:
- 프로젝트에 repository 패턴이 있는데 직접 DB 호출
- 기존 에러 핸들링 패턴을 무시하고 새 방식 도입
- 같은 역할의 컴포넌트인데 다른 구조로 작성

#### 에이전트 설계에서의 적용

- 기억 시스템: 감정·해석·연상 등 다양한 기억을 **fact + intention** 두 노드 타입으로 통일
- 산출물: 검색 결과, 분석, 메모를 **문서**라는 단일 추상화로 통일
- LLM 호출: 에이전트 수준 / 도구 수준 **두 가지 패턴**으로 통일

### 기술적 결 (Technical Grain)
제품의 본질(UX·도메인·운영)과 기술이 강제하는 세계관이 맞물리는 정도. 맞으면 단순, 안 맞으면 우회·복잡성.

판단 기준:
1. 도메인이 리소스(명사) 중심인가, 워크플로(동사) 중심인가?
2. UX가 즉시 응답인가, 실행→대기→수정 반복인가?
3. 운영 관측이 가능한가?

### LLM 호출 이원화: 에이전트 vs 도구

| | 에이전트 수준 | 도구 수준 |
|---|---|---|
| 역할 | 전략적 판단 (대화 맥락·기억·시나리오) | 단발 작업 (좁은 입력 → 구조화된 출력) |
| 구조 | 오케스트레이터 (파싱→감지→기억→프롬프트→스트리밍→저장) | 공통 경로 (프롬프트→호출→파싱→검증→결과) |
| 관측 | 턴/스텝 단위 | 호출 단위 |
| 에러 | 재시도/폴백 | skip/throw |
| 확장 | 더 똑똑하게 | 더 많은 종류로 |

### 아키텍처: 3-Plane
- **Product Plane** — UX 경험 (진행 표시, 중단, 되돌리기, 부분 재생성, 맥락 누적)
- **Agent Plane** — 정책 집행 (자율성 강제, 실행 기록, 안전장치)
- **Execution Plane** — 비동기 실행 (재시도, 비용 통제, 관측, 피드백 루프)

### 관측 체계

1. **계측** — OpenTelemetry GenAI 시맨틱 규약
2. **에이전트 관측** — 추론 과정, 도구 호출, 의사결정 경로
3. **서비스 관측** — 에러·성능·이상 탐지, 에이전트 결정과 상관 분석
4. **비용 관측** — 토큰, API 비용을 세션·태스크·모델별 추적
5. **피드백 루프** — 오류 → 평가 → 개선 → 재배포

핵심: 행위뿐 아니라 **추론 과정(why)**도 기록. 개방 표준(OpenTelemetry)으로 도구 종속 회피.

### 지식 공급
- Context7 MCP — 라이브러리 버전별 최신 문서
- MCP 표준 — 외부 데이터·도구·워크플로 연결
- 버전 인식 — 매니페스트에서 의존성 버전 읽기
- 출처·신뢰도 명시 — 불확실할 때 밝힌다

### 웹 도메인 계약
1. 주소·복원 — URL = 상태 식별자, 새로고침/공유/딥링크 동일 재현
2. 히스토리 — 뒤로가기/앞으로가기가 앱 상태 전이와 일치
3. HTTP 의미론 — GET=조회, 캐시/멱등성/재시도가 메서드와 일치
4. 상태 경계 — 공유=URL/서버, 일시적=로컬
5. 에러·로딩 — 라우트별 명시적 처리

### 원칙-구현 정합성 문서
프로젝트에 원칙 문서가 있으면 코드에서 어떻게 집행되는지 명시하는 정합성 문서를 작성한다.
1. 원칙 → 상태/코드 매핑 테이블
2. 실패 사례와 원인
3. 코드 리뷰 체크리스트

### 프로젝트 문서 계층
```
대원칙 (서비스 정체성 + 동료 원칙)
  → 설계 프레임워크 (자율성, 설계 규칙, 안전, 제어감)
    → 서비스 스펙 (원칙의 구체 적용)
      → 기술 아키텍처 (3-Plane, 관측, 데이터 모델)
        → 상태관리 명세
          → 정합성 문서
  → 코딩 규칙
```
각 계층은 상위를 참조하되 재서술하지 않는다.

---

## 새 AI 기능 설계 체크리스트

```
1. 되돌림 비용은?         → 높으면 L1~L3, 낮으면 L4~L5
2. 판단의 개인성은?       → 높으면 사용자 주도, 낮으면 AI 주도
3. 맥락 전환 비용은?      → 높으면 자동화 유리, 낮으면 수동 무방
4. 세 기준 종합 → 자율성 수준 확정
5. 검증 장치 설계
6. 안전망 설계
7. 맥락 분리 여부
```

---

> 이 문서는 ai-service-design-principles.md + technical-grain.md를 통합한 것이다. 출처: Light House 프로젝트 실전 적용에서 도출.
