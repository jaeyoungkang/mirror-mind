# 세션 17 — 에이전트 관측 구조 설계 + LLM 이원화 원칙

**날짜**: 2026-02-25
**주제**: lighthouse 에이전트 사고 과정 관측을 위한 코드 구조 리팩토링 + 도구 수준 LLM 추상화

## 흐름

1. 세션 시작 — 기억 시스템 첫 활용. 56개 에피소드에서 맥락 복원
2. 사용자 제안: 응답 속도 개선 전에 에이전트 사고 과정을 로그+시각화하여 플로우 점검
3. 관측 방향 합의: dev 페이지 타임라인 뷰(B안), LLM 판단 중심 관측
4. **핵심 인사이트**: "관측 전에 관측하기 좋은 구조를 만들어야 한다" → "관측 대상 자체도 관측하기 좋은 구조인지 검토해야 한다"
5. 설계: orchestrator 추출 + TurnContext 트리 모델 + 도구 래핑 패턴
6. 구현 에이전트가 구조 변경 완료 (route.ts 214줄 → 20줄, orchestrator.ts 298줄 신규)
7. 사용자 인사이트: "에이전트 수준과 도구 수준 LLM을 별도로 생각해야 한다"
8. 도구 수준 LLM 추상화 설계 (executeJudgment 공통 실행 경로)
9. 구현 에이전트가 추상화 완료 (llm-judgment.ts 115줄, 6개 도구 파일 교체)
10. LLM 이원화 패턴을 technical-grain.md에 역수입

## 핵심 결정

### 관측 가능한 구조 = 함수 경계가 관측 경계
- route.ts의 모놀리식 핸들러를 orchestrator.ts로 추출
- 5개 페이즈(parse-input, detect-scenario, load-memory, build-prompt, llm-stream)로 분리
- TurnContext가 페이즈/스텝/도구 호출을 트리로 기록
- AI SDK onStepFinish로 스텝별 LLM 텍스트 + 도구 선택을 관측

### LLM 호출 이원화
- 에이전트 수준: streamText, 멀티스텝, 도구 선택, 자율성 → orchestrator.ts
- 도구 수준: 단발 Gemini 호출, 구조화된 I/O → llm-judgment.ts의 executeJudgment
- 분리 근거: 관측 단위, 에러 처리, 확장 방향이 모두 다르다

### 도구 수준 LLM 추상화 경계
- 추상화 대상: Gemini 호출 + 응답 파싱 + Zod 검증 + 에러 처리 + 관측
- 도구별 영역 유지: 프롬프트 구성, 후처리(아티팩트, 인덱스 재매핑)

## 미완료

- 관측 지점 추가 (orchestrator 페이즈에서 실제 메타데이터 기록)
- dev 페이지 타임라인 뷰 구현
- 응답 속도 분석 및 개선 (관측 데이터 기반)

## 감정/관계

- 사용자가 "관측 전에 구조부터" → "관측 대상도 구조 검토" 순서로 사고를 깊이 이끌었다
- AI가 설계를 제시하면 사용자가 한 단계 더 깊은 질문으로 방향을 정교화하는 패턴
- 마무리에서 "정리되니 마음이 편안하다"는 표현 — 실전 구조가 원칙으로 올라올 때의 만족감
